#Resolving DNS queries with Python

I read a nice [short cartoon](https://howdns.works/) about how DNS works,
and I wanted to understand it in more detail. I thought it would be a nice
learning exercise to write a DNS resolver in Python - we're not going to
performance here, but instead for clean readable code and clear
explanations.

##Literate Python stuff

Before we get into the code let's explain this whole literate Python thing
a bit. I decided to use the [Pweave](https://github.com/mpastell/Pweave)
module, since it has the most options for output formats (.md, .tex,
.html, .rst, etc) and also lets you write you document's markup in
a variety of languages.

If you clone the repo to your computer you can do a `pip install -r
requirements.txt` to get all the dependencies for this project (including
Pweave). Then if you want to actually run the program you can do:

```bash
Ptangle pyresolve.mdw
```

which will 'tangle' the code. This terminology comes from Knuth's original
literate programming setup, which was called WEB and consisted of LaTeX
markup and Pascal source code. 'Weaving' a WEB document is taking this
combined source and producing a cleanly typeset document, and 'tangling'
the WEB is extracting just the source code from it. If you're reading this
on Github you're actually reading the output of:

```bash
Pweave -f pandoc pyresolve.mdw
```

So we 'weave' the source to get out a nice clean .md file. Tangling should
give you a `pyresolve.py` which you can run to test it out. I did not make
any attempts to test for Python 2 compatibility, so it may not work with
that. I am quite sure things are working on Python 3, however! 

We need to do a small amount of configuration to get Pweave to behave
nicely.
  
A note: Vim will open the file in Markdown mode (because it has the .md
extension) but this may not be what you want - I would rather have syntax
highlighting and plugins for the Python code when editing Python. So I did
these two bindings in my `~/.vimrc`:

```
nnoremap <Leader>lp :setlocal ft=python<cr>
nnoremap <Leader>md :setlocal ft=markdown<cr>
```

which works really smoothly!

##DNS queries

Anyway, how does DNS work? Well, it turns out it is sort of complicated!
The DNS is mainly laid out in RFCs
[1034](https://www.ietf.org/rfc/rfc1034.txt) and
[1035](https://www.ietf.org/rfc/rfc1035.txt), which (although very
informative) are quite long. 

The first bit of information we need is in 1035, in section 4 (Messages).
This is how the packet we're going to build for our DNS query is laid out:

```
+---------------------+
|        Header       |
+---------------------+
|       Question      | the question for the name server
+---------------------+
|        Answer       | RRs answering the question
+---------------------+
|      Authority      | RRs pointing toward an authority
+---------------------+
|      Additional     | RRs holding additional information
+---------------------+
```

(the IETF's ASCII art skills are legendary!). Basically, I think we`re
going to try to do this as some sort of bytestring, which Python gives us
lots of tools to work with.

But first, some import statements!

<<>>=
import random
import sys
@

Alright, so basically the packet is going to contain a bunch of different
sections, each of which we'll handle as a different object.

###Header

The header is the first part of our query. It holds some information about
what we are asking the server for, what kind of question, etc. The IETF
kindly supplies us with more ASCII perfection:

```
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QDCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ANCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    NSCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ARCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

Great, we're going to make a new class to hold all this info! Here is what
we need to do:

1. **ID** This is a 16 bit identifier that we assign when we generate
  a query, and the responder will copy it onto our reply. This lets us
  match the response to the query that generated it, useful if we are
  firing off lots of them!

2. **QR**: this is a one-bit field which specifies whether this is a query
   (0) or a response (1). We want 0!

3. **OPCODE**: this identifies the query type. We just want standard query,
   which means we want to use the value 0

4. **AA**: this is 'authoritative answer', which will get changed in the
   response.

5. **TC**: may change to 1 in the response to indicate that the response
   was truncated (due to size constraints)

6. **RD**: indicates we'd like the server to resolve our query
   recursively.

7. **RA**: the server can set this to indicate if recursion support is
   available (we'll leave it 0)

8. **Z**: this is reserved! For magical future use. We'll leave it set to
   zero.

9. **RCODE**: this gets set by the server when it's formulating its
   response. 0 indicates success, 1-5 indicate various kinds of failures
   or errors.

10. **QDCOUNT**: 16 bits to specify how many questions we want to ask 
    (this is passed in as 'numq').

11. **ANCOUNT**: another 16 bits to specify how many resource records
    we'll put the in the answer section (for the server to write into).

12. **NSCOUNT**:



<<>>=
class Header(object):
    def __init__(self, numq):
        self.id = self.genid()
        self.qr = 0b0
        self.opcode = 0b0
        self.aa = 0b0
        self.tc = 0b0
        self.rd = 0b0
        self.ra = 0b0
        self.z = 0b000
        self.rcode = 0b0000
        self.qdcount = numq
        self.ancount = numq
        self.nscount = 0b0
        self.arcount = 0b0
        self.header = bytearray()

    def genid(self):
        temp = random.choice(range(0, 65535))
        return temp.to_bytes(2, sys.byteorder)
@
